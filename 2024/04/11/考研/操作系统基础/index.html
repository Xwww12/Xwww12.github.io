

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xw">
  <meta name="keywords" content="">
  
    <meta name="description" content="操作系统基础概述什么是操作系统​	操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统提供的功能 处理机（CPU）管理 存储器管理 文件管理 设备管理  操作系统的目标 作为系统资源的管理者 向上提供方便易用的服务 图形界面GUI">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://xwww12.github.io/2024/04/11/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="操作系统基础概述什么是操作系统​	操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统提供的功能 处理机（CPU）管理 存储器管理 文件管理 设备管理  操作系统的目标 作为系统资源的管理者 向上提供方便易用的服务 图形界面GUI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%94%98%E7%89%B9%E5%9B%BE%E4%BE%8B%E9%A2%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%88%86%E6%88%90%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9B%BE.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%99%9A%E6%8B%9F%E6%9C%BA.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/PCB%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%85%B3%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%80%E4%B8%AD%E6%96%AD.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/TCB.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/peterson%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/TS%E6%8C%87%E4%BB%A41.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/TS%E6%8C%87%E4%BB%A42.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F1.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F2.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%93%BE.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E9%A1%B5%E8%A1%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%BF%AB%E8%A1%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%BF%AB%E8%A1%A8%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%AE%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%94%B9%E8%BF%9B%E5%9E%8B%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9D%A5%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E9%A1%BA%E5%BA%8F%E7%B4%A2%E5%BC%95%E8%A1%A8.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%B6%85%E7%BA%A7%E5%9D%97.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E7%A1%AC%E9%93%BE%E6%8E%A5.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80%E7%A3%81%E7%9B%98.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png">
<meta property="og:image" content="http://xwww12.github.io/img/os_img/vnode.png">
<meta property="article:published_time" content="2024-04-11T12:45:50.435Z">
<meta property="article:modified_time" content="2024-05-13T14:48:18.821Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://xwww12.github.io/img/os_img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png">
  
  
  
  <title>操作系统 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xwww12.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>夕立ち的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner_img/Reimu1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">操作系统</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        xw
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-11 20:45" pubdate>
          2024年4月11日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          118 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>​	操作系统（Operating System， OS）是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统<strong>软件</strong></p>
<h3 id="操作系统提供的功能"><a href="#操作系统提供的功能" class="headerlink" title="操作系统提供的功能"></a>操作系统提供的功能</h3><ul>
<li>处理机（CPU）管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul>
<li>作为系统资源的管理者</li>
<li>向上提供方便易用的服务<ul>
<li>图形界面GUI</li>
<li>命令接口<ul>
<li>联机命令接口：交互式，用户一句，系统一句，如cmd</li>
<li>脱机命令接口：批处理，如bat</li>
<li>程序接口：在代码中通过<strong>系统调用</strong>（广义接口）来使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li><p><strong>并发</strong></p>
<p>  并发：同一时间交替运行多个程序</p>
<p>  并行：同一时间同时运行多个程序（多核CPU）</p>
</li>
<li><p><strong>共享</strong></p>
<p>  互斥共享：一个时间段内只允许一个进程访问该资源（临界资源）</p>
<p>  同时访问：同一时间段内多个进程”同时“访问</p>
<p>  <strong>并发和共享是操作系统两个最基本的特征</strong></p>
</li>
<li><p><strong>虚拟</strong></p>
<p>  空分复用：内存分给多个进程使用，让用户觉得能使用的内存大于物理内存（虚拟内存）</p>
<p>  时分复用：处理机在各个微小的时间段内交替为各个进程服务</p>
</li>
<li><p><strong>异步</strong></p>
<p>  进程以不可预知的速度执行</p>
<p>  只有系统拥有并发性，才有可能导致异步</p>
</li>
</ul>
<h3 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h3><p><img src="/img/os_img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>手工操作阶段</strong>：用户独占，资源利用率底，（无操作系统）</p>
</li>
<li><p><strong>批处理阶段</strong></p>
<ul>
<li><p><strong>单道批处理系统</strong>：</p>
<p>  将一批作业放入磁带执行，一次只能执行一道程序，<strong>监督系统负责作业的输入输出</strong>，CPU有大量时间在等待IO完成</p>
<p>  <img src="/img/os_img/%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p><strong>多道批处理系统</strong>：</p>
<ul>
<li><p>优点：</p>
<p>  在输入和输出程序的时候也能进行计算；</p>
<p>  当某道程序因为请求IO操作而暂停运行时，CPU变去运行另一道程序；</p>
<p>  多道、宏观并行、微观串行（轮流使用CPU）；</p>
</li>
<li><p>缺点：</p>
<p>  响应时间较长，不提供人机交互；</p>
</li>
</ul>
<p>  <img src="/img/os_img/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
<li><p><strong>分时操作系统</strong></p>
<p>  以<strong>时间片</strong>为单位轮流为各个用户&#x2F;作业服务，请求能被及时响应，主要用于<strong>交互式作业</strong>。但不能优先处理一些紧急任务</p>
</li>
<li><p><strong>实时操作系统</strong></p>
<ul>
<li>硬实时系统：必须在觉得严格的规定时间内完成</li>
<li>软实时系统：能接收偶尔超时</li>
</ul>
</li>
<li><p>个人计算操作系统、网络操作系统、分布式操作系统。。。</p>
</li>
</ul>
<blockquote>
<p>求CPU使用率的题用甘特图比较好求</p>
<p><img src="/img/os_img/%E7%94%98%E7%89%B9%E5%9B%BE%E4%BE%8B%E9%A2%98.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h3><p><strong>指令</strong>：</p>
<ul>
<li>特权指令：不允许用户直接用的指令，如IO指令、关中断指令等</li>
<li>非特权指令：仅限于访问用户的地址空间</li>
</ul>
<p><strong>CPU的运行模式</strong>：</p>
<ul>
<li>用户态（目态）：应用程序运行在用户态</li>
<li>内核态（管态）：操作系统内核运行在内核态</li>
<li>内核态 –&gt; 用户态：执行特权指令，修改<strong>PSW（程序状态字寄存器）</strong>标志位</li>
<li>用户态 –&gt; 内核态：<strong>中断</strong>，硬件自动完成切换</li>
</ul>
<p><strong>操作系统的内核组成</strong>：</p>
<ul>
<li>与硬件关联较紧密的模块<ol>
<li>时钟管理：给用户提供系统时间、分时操作系统的时钟中断来切换进程、实时操作系统的截止时间</li>
<li>中断处理：保护和回复中断现场的信息，转移控制权到相关处理程序</li>
<li>原语：原子性，最接近硬件的部分，调用频繁</li>
<li>管理：进程管理、存储器管理、设备管理</li>
</ol>
</li>
<li>运行频率较高的模块</li>
</ul>
<h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul>
<li><p>作用<br>  中断是让操作系统内核夺回CPU使用权的<strong>唯一手段</strong>，发生中断时会立即切换回核心态</p>
</li>
<li><p>中断的类型</p>
<ul>
<li><p><strong>内中断</strong>（异常、例外）：<br>  中断信号来源于CPU内部</p>
<ol>
<li>陷阱、陷入指令（trap指令、访管指令）：程序请求内核的服务时使用</li>
<li>故障：错误条件引发，如缺页故障、地址越界</li>
<li>终止：使得CPU无法继续执行的硬件故障</li>
</ol>
</li>
<li><p><strong>外中断</strong>（中断）：<br>  中断信号<strong>来源于CPU外部</strong>，如时钟中断</p>
<ol>
<li>可屏蔽中断：通过INTR线（Interrupt Request line）发出中断请求，可多重中断</li>
<li>不可屏蔽中断：通过INM线（Non-Maskable Interrupt line）发出请求，多为硬件故障</li>
</ol>
<ul>
<li>时钟中断：表示一个固定的时间片已到</li>
<li>IO中断请求：表示输入输出处理已经完成</li>
</ul>
</li>
</ul>
</li>
<li><p>中断基本原理<br>  CPU根据中断的类型去查询<strong>中断向量表</strong>，找到对应<strong>中断处理程序</strong>的入口地址</p>
<p>  如果处理程序能够解决问题，则通过<strong>中断返回指令</strong>返回用户程序继续执行</p>
<p>  如果是不可恢复的致命错误，则终止用户程序</p>
</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li><p>作用</p>
<p>  应用程序通过系统调用来请求操作系统内核提供的服务，</p>
<p>  主要有设备管理、文件管理、进程管理、进程通信和内存管理，</p>
<p>  这些对系统影响非常大的指令必须由操作系统执行，以保证稳定性和安全性</p>
</li>
<li><p>何时会用到系统调用</p>
<p>  与<strong>共享资源</strong>有关的操作（存储分配、IO操作、文件管理等）</p>
</li>
<li><p>系统调用过程</p>
<ol>
<li>先通过传参指令将参数传到寄存器中</li>
<li>再通过陷入指令转入中断处理程序、<strong>硬件自动保护中断现场</strong>（程序计数器PC、PSW、通用寄存器）</li>
<li>处理完后<strong>恢复现场</strong>、返回用户程序</li>
</ol>
</li>
</ul>
<h3 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h3><ol>
<li><p><strong>宏内核</strong>（单内核、大内核）</p>
<p> 系统的主要功能模块都运行在核心态</p>
</li>
<li><p><strong>微内核</strong></p>
<p> 只保留最基本的功能在内核，如与硬件处理紧密相关的部分</p>
<ol>
<li>进程管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理</li>
</ol>
<p> <strong>特点</strong>：</p>
<ol>
<li>足够小的内核</li>
<li>基于客户&#x2F;服务器模式</li>
<li>应用“机制与策略分离”原理</li>
<li>采用面向对象</li>
</ol>
<p> 优点：扩展灵活、可靠安全、可移植性、分布式计算</p>
<p> 缺点：微内核用户态和内核态的转换比宏内核频繁，<strong>性能偏低</strong></p>
</li>
<li><p><strong>分成结构</strong></p>
<p> <img src="/img/os_img/%E5%88%86%E6%88%90%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p> 每层只能调用紧邻的下一层</p>
<p> 优点：便于维护、易扩展</p>
<p> 缺点：合理定义每层比较困难、不可跨层调用效率低</p>
</li>
<li><p><strong>模块化</strong></p>
<p> <img src="/img/os_img/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p> 衡量标准：高内聚、低耦合</p>
<p> 优点：加速开发、可理解、可维护</p>
<p> 缺点：接口规定难以满足实际需求，模块间相互依赖，难以调试</p>
</li>
<li><p><strong>外核</strong></p>
<p> 在内核中运行，为虚拟机分配未经抽象的硬件资源</p>
<p> 优点：减少了硬件资源的“映射层”，提升效率</p>
<p> 缺点：降低了系统的一致性，使系统更复杂</p>
</li>
</ol>
<h3 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h3><p>作用：让操作系统运行起来</p>
<p>步骤：</p>
<ol>
<li><p>激活CPU：开始执行BIOS指令</p>
</li>
<li><p>硬件自检：在内存最开始的地方<strong>构建中断向量表</strong>，通电检查硬件</p>
</li>
<li><p>加载带有操作系统的硬盘</p>
</li>
<li><p>加载主引导记录<strong>MBR</strong>（Master Boot Recored）：作用是告诉CPU去哪个硬盘分区（<strong>活动分区</strong>）找操作系统</p>
</li>
<li><p>扫描硬盘分区</p>
</li>
<li><p>加载分区引导记录<strong>PBR</strong>：找到启动管理器</p>
</li>
<li><p>加载<strong>启动管理器</strong>：找到并激活引导操作系统的程序</p>
</li>
<li><p>加载操作系统</p>
<p> <img src="/img/os_img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><strong>第一类虚拟机管理系统</strong></p>
<p>虚拟机管理程序运行在<strong>内核态</strong></p>
<p>向上提供若干虚拟机，虚拟机作为<strong>用户态</strong>的一个进程运行，所在的内核态为<strong>虚拟内核态</strong></p>
<p><strong>第二类虚拟机管理系统</strong></p>
<p>在宿主操作系统上运行，如VMWare</p>
<p><img src="/img/os_img/%E8%99%9A%E6%8B%9F%E6%9C%BA.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>概念</strong>：进程是一个正在执行程序的实例，<strong>是资源分配的基本单位</strong></p>
<p><strong>组成</strong>：</p>
<ol>
<li><p>进程控制块<strong>PCB</strong>（Process Control Block）：</p>
<p> 进程创建时新建一个PCB，进程结束时回收PCB，<strong>进程存在的唯一标志</strong></p>
<p> <img src="/img/os_img/PCB%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>程序段：程序的代码段</p>
</li>
<li><p>数据段：运行时产生的数据</p>
</li>
</ol>
<p><strong>PCB组织方式</strong>：</p>
<ol>
<li>链接方式：同一状态的PCB在同一队列</li>
<li>索引方式：同一状态的PCB在同一索引表</li>
</ol>
<p><strong>特征</strong>：</p>
<ol>
<li>动态性：动态地产生、变化和消亡</li>
<li>并发性：多个进程间并发执行</li>
<li>独立性：资源分配的基本单位</li>
<li>异步性：运行速度不可预知</li>
</ol>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><img src="/img/os_img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload></p>
<p>就绪态 –&gt; 运行态：获得CPU时间片</p>
<p>运行态 –&gt; 就绪态：1. 时间片用完；2. 有优先级更高的进程在就绪态</p>
<p>运行态 –&gt; 阻塞态：请求某一资源或等待某一事件发生（主动）</p>
<p>阻塞态 –&gt; 就绪态：等待的事件到来时（被动）</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>创建&#x2F;撤销&#x2F;转换进程</p>
<p><strong>原语</strong>：</p>
<ul>
<li><p>原子性：运行必须一气呵成，不可中断</p>
</li>
<li><p>通过关中断和开中断实现原子性</p>
<p>  <img src="/img/os_img/%E5%85%B3%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%80%E4%B8%AD%E6%96%AD.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p><strong>创建进程过程</strong>：</p>
<ol>
<li>分配PID，申请空白PCB</li>
<li>分配运行所需资源</li>
<li>初始化PCB：包括标志信息、CPU状态信息、CPU控制信息和进程优先级等</li>
<li>插入就绪队列</li>
</ol>
<p><strong>终止进程过程</strong>（正常结束、异常结束、外界干预）：</p>
<ol>
<li>从PCB中读取进程状态</li>
<li>（如果在运行）终止运行、终止子进程</li>
<li>将资源归还父进程&#x2F;操作系统</li>
<li>将PCB从队列中删除</li>
</ol>
<p><strong>阻塞进程操作</strong>（主动行为）：</p>
<ol>
<li>调用<strong>阻塞原语</strong></li>
<li>通过PID找到PCB</li>
<li>（如果在运行）<strong>保护现场</strong>，将上下文保存到PCB中</li>
<li>将PCB插入到相应等待队列</li>
</ol>
<p><strong>唤醒进程操作</strong>（被动行为）：</p>
<ol>
<li>调用<strong>唤醒原语</strong></li>
<li>在等待队列中找到该PCB</li>
<li>从阻塞队列中移除，设置为就绪态，插入到就绪队列</li>
</ol>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>高级通信主要有三种方式：</p>
<ol>
<li><p>共享存储</p>
<p> 基于数据结构或共享空间，互斥访问</p>
<p> <img src="/img/os_img/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>消息传递</p>
<p> 通过原语传递指定格式的消息，直接发给对方进程或发给信箱</p>
<p> <img src="/img/os_img/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>管道通信</p>
<p> 半双工通信，固定大小，先进先出</p>
<p> 满时写进程堵塞，空时读进程堵塞</p>
</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>引入线程的目的是减小程序在并发执行时所付出的时空开销</p>
<p>TCB由线程ID、PC、寄存器集合、运行状态、优先级和堆栈指针等组成</p>
<p><img src="/img/os_img/TCB.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>线程是调度的最小单位</strong></p>
<h3 id="线程特点"><a href="#线程特点" class="headerlink" title="线程特点"></a>线程特点</h3><ul>
<li>不同线程可以执行相同程序</li>
<li>同一进程的线程共享进程资源</li>
<li>各个CPU可为一个进程内的各线程服务，缩短进程的处理时间</li>
<li>被终止但尚未释放资源的线程被其他线程调用时，从终止态重新开始运行</li>
</ul>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ol>
<li><p>用户级线程（UTL）</p>
<p> 用代码模拟线程，内核感知不到线程的存在</p>
<p> 优点：</p>
<ol>
<li>节省了模式切换的开销</li>
</ol>
<p> 缺点：</p>
<ol>
<li>一个线程阻塞，所有线程都阻塞</li>
<li>每次只能运行一个线程</li>
</ol>
<p> <img src="/img/os_img/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>内核级线程（KTL）</p>
<p> 在内核的支持下运行的</p>
<p> 优点：</p>
<ol>
<li>发挥多核CPU的优势</li>
<li>一个线程阻塞，其他线程不会跟着阻塞</li>
</ol>
<p> 缺点：</p>
<ol>
<li>线程切换需要切换到核心态，开销较大</li>
</ol>
<p> <img src="/img/os_img/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>组合方式</p>
<p> <img src="/img/os_img/%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="/img/os_img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<h2 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h2><p>为什么要CPU调度：CPU和外部设备的速度差距大，等待外部设备会浪费CPU资源</p>
<h3 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h3><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>方向</th>
<th>频率</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作业调度</strong>（高级调度）</td>
<td>从外存后备队列选择一个作业，创建进程</td>
<td>外存 -&gt; 内存</td>
<td>低</td>
</tr>
<tr>
<td><strong>内存调度</strong>（中级调度）</td>
<td>从外存将挂起的的作业调回内存</td>
<td>外存 -&gt; 内存</td>
<td>中</td>
</tr>
<tr>
<td><strong>进程调度</strong>（低级调度）</td>
<td>从就绪队列中选择一个进程分配给处理机</td>
<td>内存 -&gt; CPU</td>
<td>高</td>
</tr>
</tbody></table>
<blockquote>
<p>中级调度的作用是为了提高内存的利用率，将暂时不能运行的进程挂起来</p>
<p>挂起和阻塞的区别：挂起的进程在外存，阻塞的进程还在内存；就绪态和阻塞态的进程可能会被挂起</p>
</blockquote>
<h3 id="star-评价指标"><a href="#star-评价指标" class="headerlink" title=":star:评价指标"></a>:star:评价指标</h3><table>
<thead>
<tr>
<th>指标</th>
<th>怎么算</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>CPU利用率</td>
<td>有效工作时间 &#x2F; (有效工作时间 + 空闲等待时间)</td>
<td></td>
</tr>
<tr>
<td>系统吞吐量</td>
<td>完成作业数 &#x2F; 花费时间</td>
<td>单位时间完成的作业量</td>
</tr>
<tr>
<td>周转时间</td>
<td>作业完成时间 - 作业提交时间</td>
<td>作业提交到完成的时间</td>
</tr>
<tr>
<td>平均周转时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>带权周转时间</td>
<td>周转时间 &#x2F; 实际运行时间</td>
<td>&gt;1，周转时间为运行时间的多少倍</td>
</tr>
<tr>
<td>平均带权周转时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>等待时间</td>
<td>等待CPU的时间</td>
<td>进程等待时间不包括IO时间</td>
</tr>
<tr>
<td>响应时间</td>
<td>首次响应时间 - 提交时间</td>
<td></td>
</tr>
</tbody></table>
<h3 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h3><p><img src="/img/os_img/%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>排队器：将就绪进程按照一定策略排成一个或多个队列</li>
<li>分派器：分配CPU给新进程（进程调度）</li>
<li>上下文切换器：切换进程上下文（进程切换）</li>
</ul>
<h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><ol>
<li>创建新进程时，CPU选择运行父进程还是子进程</li>
<li>运行的进程正常结束或异常终止</li>
<li>阻塞时（IO请求、信号量操作等）</li>
<li>IO完成后的IO中断</li>
<li>有更高优先级的进程进入就绪队列</li>
<li>时间片用完</li>
</ol>
<blockquote>
<p>操作系统内核程序临界区：一般是访问某种内核数据结构，不能进行调度和切换</p>
<p>临界区：访问临界资源，等待IO时应该进行进程切换</p>
</blockquote>
<p><strong>不能进行进程调度和切换的场景</strong></p>
<ol>
<li>在处理中断的过程</li>
<li>屏蔽中断的原子操作过程（加解锁、保护中断现场等）</li>
</ol>
<p><strong>调度方式</strong></p>
<ol>
<li><p>非抢占调度方式</p>
<p> 优点：实现简单、开销小，适合早期批处理系统</p>
<p> 缺点：不能用于分时系统和大多数实时系统</p>
</li>
<li><p>抢占调度方式</p>
<p> 提高吞吐率和响应效率有好处</p>
<p> 根据优先权、短进程优先、时间片原则等判断优先级</p>
</li>
</ol>
<h3 id="star-调度算法"><a href="#star-调度算法" class="headerlink" title=":star:调度算法"></a>:star:调度算法</h3><p><strong>早期批处理系统中使用的调度算法</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>是否抢占</th>
<th>是否导致饥饿</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务(FCFS)</td>
<td>按作业提交时间执行</td>
<td>×</td>
<td>×</td>
<td>简单</td>
<td>对短作业不利，效率低</td>
</tr>
<tr>
<td>短作业优先(SJF)</td>
<td>每次调度时选择就绪队列里运行时间最短的</td>
<td>×</td>
<td>√</td>
<td>平均等待时间、平均周转时间相对较短</td>
<td>对长作业不利</td>
</tr>
<tr>
<td>最短剩余时间优先(SRTN)</td>
<td>每次调度、进程进入就绪队列时选择就绪队列里剩余运行时间最短的</td>
<td>√</td>
<td>√</td>
<td>平均等待时间、平均周转时间“最”优</td>
<td>对长作业不利</td>
</tr>
<tr>
<td>高响应比优先(HRRN)</td>
<td>每次调度时选择就绪队列里响应比<strong>最高的</strong>(响应比：(等待时间 + 运行时间) &#x2F; 运行时间)</td>
<td>×</td>
<td>×</td>
<td>综合考虑了等待时间和运行时间</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>这些算法没有关注响应时间和任务的紧急程度，交互性差</p>
</blockquote>
<p><strong>分时操作系统中使用的调度算法：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>是否抢占</th>
<th>是否导致饥饿</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>时间片轮转(RR)</td>
<td>每隔一段时间产生一个时钟中断，激活调度程序调度，时间片设计最好使切换开销占比不超过1%</td>
<td>√</td>
<td>×</td>
<td>公平，响应快</td>
<td>不区分紧急任务，时间片设置不合理开销大</td>
</tr>
<tr>
<td>优先级调度算法</td>
<td>调度时选择在就绪队列中优先级最高的进程</td>
<td>×</td>
<td>√</td>
<td>可灵活调整对进程的偏好</td>
<td>可能导致饥饿</td>
</tr>
<tr>
<td>多级反馈队列调度算法</td>
<td>如下图</td>
<td>√</td>
<td>√</td>
<td>兼顾长短作业，有较好的响应时间，通用</td>
<td>复杂</td>
</tr>
</tbody></table>
<p><img src="/img/os_img/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>静态优先级：创建时决定优先级，之后一直不变</p>
<p>动态优先级：创建时有一个初始值，根据情况调整优先级</p>
<p>优先级从以下几点考虑：</p>
<p>通常：</p>
<ul>
<li>系统进程 &gt; 用户进程</li>
<li>前台进程 &gt; 后台进程</li>
<li>IO型进程 &gt; 计算型进程</li>
<li>交互型进程 &gt; 非交互型进程</li>
</ul>
</blockquote>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h3><p>临界资源：一次仅允许一个进程使用的资源</p>
<p>临界区：访问临界资源的那段代码</p>
<blockquote>
<p>临界资源的访问过程：</p>
<p>1） 进入区：检查是否可进入临界区、设置正在访问临界区标志</p>
<p>2） 临界区：又称临界段</p>
<p>3） 退出区：秦楚正在访问临界区标志</p>
<p>4） 剩余区：代码其他部分</p>
</blockquote>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>直接制约关系</p>
<p>多个进程合作完成同一个任务</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>间接制约关系</p>
<p>进程间互斥地访问临界资源</p>
<p><strong>实现互斥的准则</strong></p>
<ol>
<li>空闲让进：临界区空闲时，允许一个进程进入</li>
<li>忙则等待：有进程进入临界区时，其他进程等待</li>
<li>有限等待：要保证进程在有限时间里进入临界区</li>
<li>让权等待：进程不能进入临界区时，要让出CPU</li>
</ol>
<h3 id="基本实现方式"><a href="#基本实现方式" class="headerlink" title="基本实现方式"></a>基本实现方式</h3><p><strong>软件实现方式</strong></p>
<ol>
<li><p>单标志法</p>
<p> 用一个turn表示能访问临界区的进程号</p>
<p> 若一个进程不再进入临界区，则另一个也无法进入，违反“空闲等待”</p>
<p> <img src="/img/os_img/%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>双标志先检查法</p>
<p> 一个数组flag[2]表示进程想要进入的意愿</p>
<p> 可能导致两个进程都通过进入区，违反“忙则等待”</p>
<p> <img src="/img/os_img/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>双标志后检查法</p>
<p> 先设置意愿，再进入进入区</p>
<p> 可能导致都卡在进入区，违反“空闲等待”、“有限等待”，导致饥饿</p>
<p> <img src="/img/os_img/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>Peterson算法</p>
<p> 同时有表示意愿的flag[]和表示能访问临界区的进程号的turn</p>
<p> 如果只有一个进程要进入临界区，会导致一直在while里，违反“让权等待”</p>
<p> <img src="/img/os_img/peterson%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<p><strong>硬件实现方式</strong></p>
<ol>
<li><p>中断屏蔽</p>
<p> 通过关中断、开中断实现互斥</p>
<p> 缺点：开关中断需要切换到内核态，效率低；只能在单处理机上使用</p>
</li>
<li><p>TestAndSet指令</p>
<p> 原子操作，设置和检查一气呵成，不能实现“让权等待”</p>
<p> <img src="/img/os_img/TS%E6%8C%87%E4%BB%A41.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="/img/os_img/TS%E6%8C%87%E4%BB%A42.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>Swap指令</p>
<p> 原子操作，互换两个变量的值。</p>
<p> 和TS指令区别不大，只是将保存原来值的操作放到方法外</p>
</li>
</ol>
<p>TAS和Swap是<strong>硬件</strong>指令</p>
<p>相比于软件实现，硬件实现简单，支持任意多个线程。但硬件实现不能“让权等待”，会产生饥饿</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>mutex lock，互斥锁，自旋锁</p>
<p>acquire()：获得锁，release()：释放锁，操作都是原子性的</p>
<p>在多处理器系统中，自旋的消耗比进程切换小，因此常用与多处理器系统。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>整型信号量</strong></p>
<p>用一个整型S表示剩余资源数，如果为0则while不断尝试，不遵循“让权等待”。</p>
<p><strong>记录型信号量</strong></p>
<p>遵循“让权等待”</p>
<p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> value;	<span class="hljs-comment">// 剩余资源数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process</span> *<span class="hljs-title">L</span>;</span>	<span class="hljs-comment">// 等待队列</span><br>&#125; semaphore;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(semaphore S)</span> &#123;<br>    S.value--;<br>    <span class="hljs-keyword">if</span> (S.value &lt; <span class="hljs-number">0</span>) &#123;<br>        add this process to S.L;	<span class="hljs-comment">// 进入阻塞队列</span><br>        block(S.L)	<span class="hljs-comment">// 阻塞当前进程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(semaphore S)</span> &#123;<br>    S.value++;<br>    <span class="hljs-keyword">if</span> (S.value &lt;= <span class="hljs-number">0</span>) &#123;<br>        remove a proceess P from S.L;	<span class="hljs-comment">// 将一个进程从阻塞队列中移除</span><br>        wakeup(P);	<span class="hljs-comment">// 唤醒进程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p><strong>生产者-消费者问题</strong></p>
<p>信号量设置：</p>
<ol>
<li>mutex：互斥信号量，用于控制互斥访问缓冲池</li>
<li>full：记录“满”的缓冲区数，初值0</li>
<li>empty：记录“空”的缓冲区数，初值n</li>
</ol>
<p>注意：</p>
<p>要先判断“空”&#x2F;“满”的缓冲区数，再获取mutex，否则可能抱着锁阻塞，导致<strong>死锁</strong></p>
<p>释放锁和“空”&#x2F;“满”的缓冲区数 + 1的顺序可以互换</p>
<p><strong>读者-写者问题</strong></p>
<p>读写、写写互斥；读读共享</p>
<p>信号量设置：</p>
<ol>
<li>count：当前读者数量，初值0</li>
<li>mutex：互斥信号量，用于控制互斥访问count，防止读进程重复对rw上锁</li>
<li>rw：互斥访问文件，初值1</li>
</ol>
<p><strong>哲学家进餐问题</strong></p>
<p><img src="/img/os_img/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload></p>
<p>信号量设置：</p>
<ol>
<li>chopstick[5]&#x3D;[1,1,1,1,1]</li>
</ol>
<p>注意：</p>
<p>如果采用贪心来获取筷子，会导致死锁</p>
<p><strong>吸烟者问题</strong></p>
<p>三个抽烟者，三种材料，每个抽烟者都缺两种不同的材料，缺的都不同。</p>
<p>一个提供者，每次提供两种材料</p>
<p>信号量设置：</p>
<ol>
<li>offer1、offer2、offer3，分别表示两种材料的组合，初值为0</li>
<li>finish：用于表示吸烟者吸完烟了，之后提供者才能放材料，初值为0</li>
</ol>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管理共享资源的资源管理器，封装了对共享资源的操作</p>
<p>各进程只能串行访问管程里的方法</p>
<p><strong>条件变量</strong>：带有阻塞队列和入队出队操作的数据结构</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁和饥饿的区别"><a href="#死锁和饥饿的区别" class="headerlink" title="死锁和饥饿的区别"></a>死锁和饥饿的区别</h3><p>进程数：死锁要两个及以上进程；饥饿可以只有一个进程</p>
<p>进程状态：死锁进程必定处于阻塞态；饥饿进程可能处于就绪态或阻塞态</p>
<p>产生原因：死锁是由于多个进程应竞争资源而造成的僵局；饥饿是由于申请的资源不能在有限时间内获取</p>
<h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ol>
<li>系统资源的竞争</li>
<li>进程推进顺序非法</li>
</ol>
<h3 id="star-死锁的必要条件"><a href="#star-死锁的必要条件" class="headerlink" title=":star:死锁的必要条件"></a>:star:死锁的必要条件</h3><ol>
<li><p><strong>互斥条件</strong>：资源最多被一个进程所占有</p>
</li>
<li><p><strong>不可剥夺</strong>：资源在未使用完之前不能被其他进程抢夺走，只能主动释放</p>
</li>
<li><p><strong>请求并保持</strong>：需要获取多个资源，对已经获得的部分资源保持不放</p>
</li>
<li><p><strong>循环等待</strong>：进程间都在等待其他进程释放自己需要的资源，形成了一条等待链。每个资源的数量都是1</p>
<p> <img src="/img/os_img/%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>破坏互斥条件</td>
<td>将互斥使用的资源改造成共享资源</td>
<td>可能导致系统不安全，很多时候要保护互斥性</td>
</tr>
<tr>
<td>破坏不可剥夺</td>
<td>请求新的资源而得不到满足时，它必须释放已经保存的所有资源</td>
<td>复杂，反复申请和释放资源增加系统开销，吞吐量降低</td>
</tr>
<tr>
<td>破坏请求与保持</td>
<td>方法一：预先静态分配：一次性将所需要的资源在运行前都给进程。方法二：进程获取运行初期需要的资源后就开始运行，后面要新的资源需要将已有的资源全部释放</td>
<td>简单，但资源浪费严重，暂时用不到的资源可能被长时间占有。</td>
</tr>
<tr>
<td>破坏循环等待</td>
<td>给资源编号，只能按顺序获取</td>
<td>不便于新增资源，可能造成资源浪费，编程麻烦</td>
</tr>
</tbody></table>
<h3 id="star-避免死锁（银行家算法）"><a href="#star-避免死锁（银行家算法）" class="headerlink" title=":star:避免死锁（银行家算法）"></a>:star:避免死锁（银行家算法）</h3><p>能找到安全序列则系统处于安全状态，否则处于不安全状态，<strong>可能</strong>导致死锁</p>
<p>定义的变量：</p>
<ol>
<li>可利用资源向量Available：Available[j] &#x3D; K表示系统中j类资源的可用数为K个</li>
<li>最大需求矩阵Max:Max[i, j] &#x3D; K表示i进程需要j类资源K个</li>
<li>分配矩阵Allocation：Allocation[i, j]&#x3D;K表示i进程已获得了j类资源K个</li>
<li>需求矩阵Need：Need[i, j] &#x3D; K表示i进程还需要j类资源K个。Need &#x3D; Max - Allocation</li>
</ol>
<h3 id="死锁检测与消除"><a href="#死锁检测与消除" class="headerlink" title="死锁检测与消除"></a>死锁检测与消除</h3><p><strong>资源分配图</strong></p>
<p><img src="/img/os_img/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p>阻塞进程：剩余资源数无法满足需求的点</p>
<p>孤立点：可分配资源并已完成分配的点，可将连着的线都去掉</p>
<p>可完全简化：将所有点变成孤立点，此时一定没有发生死锁</p>
<p>死锁定理：不可完全简化表示发生死锁</p>
<p><strong>死锁解除</strong></p>
<ol>
<li>资源剥夺法：将某些死锁进程挂起，剥夺其资源。要注意防止饥饿发生</li>
<li>撤销进程法：将某些死锁进程撤销，剥夺其所有资源，撤销进程的代价可能很大</li>
<li>进程回退法：回退到没有发送死锁的时点，要设置还原点，复杂</li>
</ol>
<blockquote>
<p>因为撤销进程后，之前运行的东西就作废了，所以代价可能很大</p>
<p>选择撤销进程时考虑的点：</p>
<ol>
<li>进程优先级</li>
<li>已执行时间</li>
<li>已经使用了多少资源</li>
<li>交互式还是批处理</li>
</ol>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="程序链接与装入"><a href="#程序链接与装入" class="headerlink" title="程序链接与装入"></a>程序链接与装入</h3><p>将代码装入的内存的步骤：</p>
<ol>
<li>编译：将代码编译成若干模块</li>
<li>链接：将编译后的模块和所需库函数链接在一起，形成完整的装入模块</li>
<li>装入：由装入模块将转入模块装入内存</li>
</ol>
<p><strong>装入方式</strong></p>
<ol>
<li><p>绝对装入</p>
<p> 只适合单道程序环境</p>
<p> 程序中的逻辑地址与内存地址完全相同</p>
<p> 绝对地址在编译或汇编时给出，或由程序员给出</p>
</li>
<li><p>可重定位装入（静态重定位）</p>
<p> 只适合早期多道批处理环境</p>
<p> 在装入时将相对地址改为绝对地址</p>
<p> 缺点：作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间</p>
<p> <img src="/img/os_img/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>动态运行时装入（动态重定位）</p>
<p> 装入内存时不修改相对地址，到真正运行时才进行内存转换，需要<strong>重定位寄存器</strong></p>
<p> 优点：不需要连续内存块，可动态申请内存块</p>
<p> <img src="/img/os_img/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<p><strong>链接方式</strong></p>
<ol>
<li><p>静态链接</p>
<p> 运行前将目标模块和库链接成完整的装入程序，之后不再拆开</p>
</li>
<li><p>装入时动态链接</p>
<p> 边装入边链接，便于修改和链接</p>
</li>
<li><p>运行时动态链接</p>
<p> 运行时需要什么模块才对它进行链接，可加快装入速度，减少内存使用，便于共享模块</p>
</li>
</ol>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>保护用户进程不影响操作系统、用户进程间不互相影响</p>
<p><strong>上下限寄存器</strong></p>
<p>存放进程的上下限地址，指令访问地址时会进行检查是否越界</p>
<p><strong>重定位寄存器、界地址寄存器</strong></p>
<p>重定位寄存器存放起始的<strong>物理地址</strong></p>
<p>界地址寄存器存放进程的最大<strong>逻辑地址</strong></p>
<p>修改这两个寄存器的值必须使用特权指令，即只有操作系统能改</p>
<p><img src="/img/os_img/%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h3><p>进程的内存映像一般包括：</p>
<ol>
<li>代码段：只读、共享</li>
<li>数据段：全局变量、静态变量</li>
<li>PCB：进程控制块</li>
<li>堆：存放动态分配的变量</li>
<li>栈：用来实现函数调用</li>
</ol>
<p><img src="/img/os_img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F1.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/os_img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h3><p><strong>覆盖技术</strong></p>
<p>将程序分为多个段，常用的常驻内存（固定区），不常用的需要时再放入内存（覆盖区）</p>
<p>必须由程序员声明覆盖结构，只用于早期操作系统</p>
<p><strong>交换技术</strong></p>
<p>内存空间紧张时，将某些进程暂时换出外存，将已具备运行条件的进程换入内存（中级调度）</p>
<p><strong>PCB是常驻再内存的</strong></p>
<p>磁盘分为：</p>
<ol>
<li>对换区：连续分配方式，速度快于文件区，追求换入换出速度</li>
<li>文件区：离散分配方式，追求存储空间的利用率</li>
</ol>
<blockquote>
<p>覆盖是在同一进程或程序中的，交换在不同进程、作业间的</p>
</blockquote>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><strong>单一连续分配</strong></p>
<p>描述：内存被分为系统区（低地址）和用户区（高地址），用户区存放用户程序，只能存一道</p>
<p>优点：简单，无外部碎片</p>
<p>缺点：只能用在单任务的操作系统中，有内部碎片，内存利用率极低</p>
<p><img src="/img/os_img/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>固定连续分配</strong></p>
<p>描述：</p>
<p>​	将用户区换分为多个分区（可以不相等），每个分区只能装一道程序</p>
<p>​	需要<strong>分区说明表</strong>来实现内存的分配于回收</p>
<p>优点：简单，无外部碎片</p>
<p>缺点：程序太大时需要使用覆盖技术，有内部碎片，内存利用率低</p>
<p><img src="/img/os_img/%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/os_img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>动态分区分配</strong></p>
<p>描述：</p>
<p>​	不会预先划分内存区，根据进程大小动态建立分区，也叫可变分区分配</p>
<p>​	用<strong>空闲分区表</strong>或<strong>空闲分区链</strong>记录内存的使用情况</p>
<p><img src="/img/os_img/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%93%BE.png" srcset="/img/loading.gif" lazyload></p>
<p>优点：无内部碎片，可根据进程大小动态建立分区</p>
<p>缺点：有外部碎片，可通过“紧凑”技术解决，但相对费时</p>
<blockquote>
<p>内部碎片：分配给进程的内存中没有用上的部分</p>
<p>外部碎片：内存中小的难以被利用上的内存块</p>
</blockquote>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><p><strong>顺序分配算法</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>分区排序顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应算法（First Fit）</td>
<td>每次都顺序查找空闲分区，将第一个满足大小的分区分配给作业</td>
<td>按地址递增顺序排列</td>
<td>保留了高位地址的大空闲区，有利于后续大作业的装入</td>
<td>低地址会出现许多小碎片，每次查找都会经过一遍，增加了开销</td>
</tr>
<tr>
<td>最佳适应算法（Best Fit）</td>
<td>将第一个能满足大小的空闲分区分配给作业</td>
<td>按容量递增</td>
<td>能流出更多大空闲分区</td>
<td>会留下<strong>最多</strong>外部碎片，性能很差</td>
</tr>
<tr>
<td>最坏适应算法（Worst Fit）</td>
<td>将第一个能满足大小的空闲分区分配给作业</td>
<td>按容量递减</td>
<td>不容易产生外部碎片</td>
<td>没有很多大分区可用，性能很差</td>
</tr>
<tr>
<td>临近适应算法（Next Fit）</td>
<td>也称循环首次适应算法，对First Fit的修改，每次从上一次查找结束的位置开始查找</td>
<td>按地址递增顺序排列</td>
<td>让高低地址的空闲分区以同等概率被分配出去</td>
<td>导致高地址没有大块空闲分区可用，<strong>通常比First Fit的效果差</strong></td>
</tr>
</tbody></table>
<p><strong>索引分配算法</strong></p>
<p>当系统很大时，空闲分区链可能很长，此时用顺序分配算法的时间开销会很大，此时往往采用索引分配算法</p>
<p>大致思想是：大小相同的空闲分区单独设立空闲分区链，再设置索引表管理这些空闲分区链</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>分区排序顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>快速适应算法</td>
<td>找到能够容纳进程的最小分区链，然后取出第一块分配给进程</td>
<td></td>
<td>效率高，不产生内部碎片</td>
<td>回收分区时，要合理合并分区，算法复杂，开销大</td>
</tr>
<tr>
<td>伙伴系统</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>哈希算法</td>
<td>建立以空闲区大小为关键字的哈希表，分配时根据大小计算空闲区所在位置</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h3><p><strong>概念</strong></p>
<p>page frame&#x3D;页框&#x3D;页帧&#x3D;物理块&#x3D;内存块：内存分为若干固定大小的分区，页面大小应是2的整数次幂</p>
<p>页&#x3D;页面：逻辑空间的分区，大小和物理块相同</p>
<p>页号：页面的编号，从0开始</p>
<p>分页管理优点：不产生外部碎片，只产生很小的内部碎片（页内碎片）</p>
<p>逻辑地址结构：</p>
<p><img src="/img/os_img/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<p>页表（页面映射表）：</p>
<p>实现从页号到物理块号的映射</p>
<p><img src="/img/os_img/%E9%A1%B5%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<p>页表寄存器：存放了页表始址和页表长度</p>
<p>地址变换机构：</p>
<p><img src="/img/os_img/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>计算</strong></p>
<p>页号&#x3D;逻辑地址&#x2F;页大小</p>
<p>偏移量&#x3D;逻辑地址%页大小</p>
<p>页表项地址&#x3D;页表始址+页号*<strong>页表项</strong>大小，里面存的就是对应的物理块号</p>
<p>物理地址&#x3D;物理块号*页面大小+偏移量</p>
<p><strong>页表项的大小</strong>：如果以字节编制，则大小应为字节的整数倍，且表示的大小要≥总页数</p>
<p>有时为了方便计算或存储其他信息，会加大页表项的长度</p>
<p><img src="/img/os_img/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>快表</strong></p>
<p>又称联想寄存器（TLB，Translation Lookaside Buffer），属于高速缓存，是硬件，用来存放最近访问的页表项	</p>
<p><img src="/img/os_img/%E5%BF%AB%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<p>如果在快表中找到要访问页表项，则只需<strong>一次访存+一次访快表</strong>就能完成存取数据</p>
<p>如果未找到，则需要<strong>两次访存+一次访快表</strong>才行</p>
<p>如果没有快表，则每次都需要<strong>两次访存</strong></p>
<blockquote>
<p>局部性原理</p>
<p>时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。</p>
<p>空间局部性：一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。</p>
</blockquote>
<p><img src="/img/os_img/%E5%BF%AB%E8%A1%A8%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>多级页表</strong></p>
<p>单级页表存在的问题有：</p>
<ol>
<li>页表需要连续的内存空间</li>
<li>可能占用很多内存</li>
</ol>
<p>多级页表可以使页表离散存储</p>
<p><img src="/img/os_img/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>注意</strong>：</p>
<ol>
<li>多级页表中各级页表的大小不能超过一个页面</li>
<li>随着级数越多，访存的次数也会增加</li>
</ol>
<h3 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h3><p>分段管理是考虑了程序员和用户，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要</p>
<p><strong>概念</strong></p>
<p>段表：保存逻辑空间和内存空间的映射关系</p>
<p>段表项：记录了始值和段长，长度是固定的</p>
<p>段表寄存器：存放段表始址和段表长度</p>
<p>地址变换机构：</p>
<p><img src="/img/os_img/%E6%AE%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<p>段内偏移量也需要判断是否越界</p>
<h3 id="分页和分段的比较"><a href="#分页和分段的比较" class="headerlink" title="分页和分段的比较"></a>分页和分段的比较</h3><p>相同点：</p>
<ol>
<li>都是非连续分配方式</li>
<li>都需要通过地址变换机构实现地址变换</li>
<li>都可以使用快表减少地址变换时间</li>
</ol>
<p>不同点：</p>
<ol>
<li>页是信息的物理单位；段是信息的逻辑单位</li>
<li>目的：分页是提高内存利用率；分段是为了更好地满足用户需求</li>
<li>长度：页的大小固定且由系统决定，对用户透明；段的大小不固定由用户决定，对用户可见</li>
<li>地址空间：分页管理的地址空间是一维的；分段管理的地址空间是二维的（分页只需要给出一个逻辑地址就能计算出页号和偏移量，由操作系统来完成；分段需要给出段号和段内偏移量，因为分段是用户决定的）</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分页管理</td>
<td>不会产生外部碎片，空间利用率高</td>
<td>不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>方便进行共享和保护</td>
<td>段太长为其分配连续空间不方便，会产生外部碎片</td>
</tr>
</tbody></table>
<h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p>将进程按逻辑模块分段，再将各段分页。结合了分页和分段的优点</p>
<p><img src="/img/os_img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>概念</strong></p>
<p>逻辑地址：由段号、页号、页内偏移量组成</p>
<p>段表项：段号（隐含的）、页表长度、页表存放块号</p>
<p>页表项：页号（隐含的）、内存块号</p>
<p>分页对于用户是不可见的，系统会根据段内地址自动划分页号和页内偏移量</p>
<p>用户要提供段号和段内偏移量（二维）</p>
<p><strong>逻辑地址转换为物理地址过程</strong></p>
<p><img src="/img/os_img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload></p>
<p>段号和页号都要检查是否越界</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>建立了“内存-外存”的两级存储器结构，利用<strong>局部性原理</strong>实现高速缓存</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>多次性：无需将作业一次性全部装入内存，只需要当前运行的那部分程序和数据装入内存即可运行</li>
<li>对换性：将需要的程序调入内存（换进），将暂不需要的调入外存（换出），由操作系统完成</li>
<li>虚拟性：用户看到的内存容量，远大于实际容量</li>
</ol>
<h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><p><strong>页表机制</strong></p>
<p>基本分页的页表项：页号、物理块号</p>
<p>请求分页的页表项新增：</p>
<ol>
<li>状态位：是否已调入内存</li>
<li>访问字段：在一段时间被访问的次数</li>
<li>修改位：调入内存后是否被修改过</li>
<li>外存地址：该页在外存的存放地址</li>
</ol>
<p><strong>缺页中断机构</strong></p>
<p>要访问的页面不在内存时，产生缺页异常（内部异常），阻塞缺页的线程</p>
<p>将要访问的页面调入内存（没有空位要淘汰其他页面），修改页表项</p>
<p>若页面被淘汰，根据是否修改来判断是否要写回外存</p>
<p><strong>地址变换机构</strong></p>
<p><img src="/img/os_img/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h3><p>驻留集：给一个进程分配的页框的集合，一般不小于工作集的大小</p>
<p>工作集：某个时间段内进程实际访问的页面集合</p>
<p>抖动：刚刚换入（换出）的页面马上又换出（换入）页面，说明分配给进程的物理块太少</p>
<p>分配策略</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>固定分配局部置换</strong></td>
<td>分配固定数目的物理块，缺页只能从分配给自己的内存中进行替换</td>
<td>难以确定应分配的物理块数，太少会频繁出现缺页中断，太多会降低资源利用率</td>
</tr>
<tr>
<td><strong>可变分配全局置换</strong></td>
<td>先分配一定数目的物理块，后从空闲物理块中根据情况增减，缺页则从空闲物理块队列中取出一块进行分配或淘汰一个未锁定的页面来分配</td>
<td>比上一种灵活，盲目增加物理块会降低系统并发度</td>
</tr>
<tr>
<td><strong>可变分配局部置换</strong></td>
<td>先分配一定数目的物理块，缺页只能从分配给自己的内存中进行替换，根据缺页率动态增减分配的物理块</td>
<td>复杂</td>
</tr>
</tbody></table>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>缺页率：缺页次数 &#x2F; 总访问页面次数</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>最佳置换算法（OPT，Optimal）</td>
<td>优先淘汰最长时间不会被访问的页面</td>
<td>性能最好，只在理论上，用来评估其他算法的性能</td>
</tr>
<tr>
<td>先进先出置换算法（FIFO）</td>
<td>优先淘汰最先进入内存的页面</td>
<td>简单，性能差，可能出现Belady异常（驻留集越大，性能反而差）</td>
</tr>
<tr>
<td>最近最久未使用算法（LRU，least recently used）</td>
<td>有限淘汰最近最久没访问的页面</td>
<td>性能好，但<strong>需要硬件支持</strong>，开销大</td>
</tr>
<tr>
<td>时钟置换算法（clock）、最近未使用算法（NRU）</td>
<td>循环扫描，淘汰第一个访问位为0的页面，将经过的访问位1改为0</td>
<td>简单，开销小，未考虑页面是否被修改过</td>
</tr>
<tr>
<td>改进型时钟置换算法</td>
<td>（访问位，修改位）形式</td>
<td>开销小，性能也不错</td>
</tr>
</tbody></table>
<p><img src="/img/os_img/%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt="最近最久未使用置换算法例题"></p>
<p><img src="/img/os_img/%E6%94%B9%E8%BF%9B%E5%9E%8B%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt="改进型时钟置换算法例题"></p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>操作系统向应用程序提供的一个系统调用。</p>
<p>在磁盘文件与进程的虚拟地址空间之间建立映射关系，将一个文件当做内存中的一个大字符数组来访问，而不通过文件IO操作来访问</p>
<p>内存映射还能用来共享内存</p>
<p><img src="/img/os_img/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9D%A5%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt="改进型时钟置换算法例题"></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>文件(File)：以硬盘为载体的存储在计算机上的信息集合。用户输入输出以文件为基本单位</p>
<p>文件的构成：存储空间、分类、索引和访问权限等</p>
<p>文件的属性：名称、类型、创建者、所有者、位置、大小、保护、创建&#x2F;修改&#x2F;存取时间</p>
<p>数据项：文件系统中最低级的数据组织形式</p>
<p>记录：一组相关的数据项的集合</p>
<h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><p>指从用户角度出发看到的文件的组织形式</p>
<p><strong>无结构文件</strong></p>
<p>由字符流构成，又称流式文件，如txt文件</p>
<p><strong>有结构文件</strong></p>
<p>由一个及以上的记录构成的文件，又称记录式文件。</p>
<p>根据记录的长度，分为：</p>
<ol>
<li>定长记录：所有记录长度相同</li>
<li>变长记录：各个记录长度不一定相同</li>
</ol>
<p>根据记录的组织形式，分为：</p>
<ol>
<li><p>顺序文件：记录按顺序排列，定长的<strong>可随机存取</strong></p>
</li>
<li><p>索引文件：为<strong>每个记录</strong>在索引表中设置一个索引表项，包含记录的指针和长度。索引表是定长的顺序文件</p>
<p> <img src="/img/os_img/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" lazyload></p>
<p> 需要额外的索引表，增加了存储开销</p>
</li>
<li><p>索引顺序文件</p>
<p> 顺序文件和索引文件的结合，<strong>一组记录</strong>对应一个索引表项提高了查找效率</p>
<p> <img src="/img/os_img/%E9%A1%BA%E5%BA%8F%E7%B4%A2%E5%BC%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>散列文件：</p>
<p> 通过记录的hash值直接计算出物理地址。具有很高的存取速度，但存在hash冲突</p>
</li>
</ol>
<h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><p>指将文件存储在外存上的存储组织形式，<strong>磁盘块</strong>的大小通常与内存的页面大小相同</p>
<p>文件分配方式：</p>
<ul>
<li><p>连续分配</p>
<p>  要求每个文件在磁盘上占有一组连续的块，进程访问磁盘时的寻道数和寻道时间最小</p>
<p>  优点：支持顺序访问和直接访问，速度快</p>
<p>  缺点：要连续的存储空间，可能产生外部碎片；要事先知道文件的长度，无法动态增长</p>
</li>
<li><p>链接分配</p>
<p>  离散分配</p>
<ul>
<li><p>隐式分配：指向下一个的指针在磁盘块中</p>
<p>  只支持顺序访问，访问磁盘次数多，效率低</p>
</li>
<li><p>显式分配：将指针都存放在一张内存中的<strong>文件分配表</strong>（File Allocation Table）里（一个磁盘对应一张，开机时调入内存）</p>
<p>  支持顺序和直接访问，减少了访问磁盘的次数，但FAT需要占用一定内存</p>
</li>
</ul>
</li>
<li><p>索引分配</p>
<p>  打开文件时，没必要将整个FAT都读入内存，因此将文件的盘块号集中成一个索引表（块）读入内存</p>
<ul>
<li><p>单级索引分配方式</p>
<p>  优点：支持直接访问</p>
<p>  缺点：索引表占用内存太大</p>
</li>
<li><p>多级索引分配方式</p>
<p>  <img src="/img/os_img/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png" srcset="/img/loading.gif" lazyload></p>
<p>  优点：加快了对大型文件的查找效率</p>
<p>  缺点：对于小文件来说，访问磁盘的次数增加了</p>
</li>
<li><p>混合索引分配方式</p>
<p>  为了照顾小、中、大文件而采用混合索引</p>
<p>  小文件采用直接索引，大文件采用间接索引</p>
<p>  <img src="/img/os_img/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
</ul>
<h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>File Control Block，存放控制文件需要的各种信息，以实现<strong>按名存取</strong></p>
<p>FCB的有序集合称为<strong>文件目录</strong></p>
<p>文件目录也是文件，称为<strong>目录文件</strong></p>
<p>为了减小FCB的体积，将除了文件名的其他信息放到<strong>索引节点</strong>中，FCB只存文件名和索引节点的指针</p>
<p>存放在磁盘上的索引节点称为<strong>磁盘索引节点</strong></p>
<p>存放在内存中的索引节点称为<strong>内存索引节点</strong>，相比磁盘索引节点新增了索引节点号、状态、访问计数等</p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>目录管理要实现按名存取</p>
<p>目录结构：</p>
<ul>
<li><p>单级目录结构</p>
<p>  只建立一张目录表，每个文件占一个目录项</p>
<p>  缺点：查找速度慢，文件不允许重名，不便于共享文件</p>
<p>  <img src="/img/os_img/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>二级目录结构</p>
<p>  分为主文件目录和用户文件目录</p>
<p>  解决了多用户间的文件重名问题，可以实现访问限制</p>
<p>  缺点：缺乏灵活性，不能文件分类</p>
<p>  <img src="/img/os_img/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>树形目录结构</p>
<p>  缺点：不便于文件共享</p>
<p>  <img src="/img/os_img/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>无环图目录结构</p>
<p>  在树形目录结构的基础上增加了一些指向同一节点的有向边，使整个目录成为一个有向无环图</p>
<p>  便于共享文件</p>
<p>  <img src="/img/os_img/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h3 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h3><p><strong>概念</strong></p>
<p>卷（volume）：包含文件系统的分区。包含目录区和文件区</p>
<p>目录区：存放FCB</p>
<p>文件区：存放文件数据</p>
<p><strong>管理方式</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>分配</th>
<th>回收</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>空闲表法</td>
<td>连续分配方式。空闲表（第一个空闲盘块号，空闲盘块数）</td>
<td>与内存相似</td>
<td>与内存相似</td>
<td>分配速度快</td>
</tr>
<tr>
<td>空闲链表法</td>
<td>空闲盘块链、空闲盘区链</td>
<td>盘块的按盘块分配、盘区的从盘区里面裁出来或几个盘区合一块</td>
<td></td>
<td>盘块简单、效率低；盘区效率高、复杂</td>
</tr>
<tr>
<td>位示图法</td>
<td>每个二进制位对应一个盘块</td>
<td>改为“1”</td>
<td>改为“0”</td>
<td>容易找到空闲盘块，位示图大小可能会很大</td>
</tr>
<tr>
<td>成组链接法</td>
<td>超级快，存放下一组空闲盘块数和空闲块号</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="/img/os_img/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt="空闲链表法"></p>
<p><img src="/img/os_img/%E8%B6%85%E7%BA%A7%E5%9D%97.png" srcset="/img/loading.gif" lazyload alt="成组链接法"></p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>创建</strong>：</p>
<ol>
<li>在外存中找到文件所需空间</li>
<li>在目录中创建对应的目录项</li>
</ol>
<p><strong>删除</strong>：</p>
<ol>
<li>找到目录中的目录项</li>
<li>回收占用的磁盘块</li>
<li>删除对应的目录项</li>
</ol>
<p><strong>读</strong>：</p>
<ol>
<li>给出要读的文件在打开文件表中的索引号（<strong>文件描述符</strong>）</li>
<li>给出要读入多少内容、放在内存哪里</li>
</ol>
<p><strong>写</strong>：</p>
<ol>
<li>给出要写的文件在打开文件表中的索引号（<strong>文件描述符</strong>）</li>
<li>给出要写回多少数据、数据在内存哪里</li>
</ol>
<p><strong>打开</strong>：</p>
<ol>
<li>找到目录中的目录项</li>
<li>将目录项复制到<strong>打开文件表</strong>中（避免多次重复检索目录）</li>
<li>之后用户使用打开文件表的编号来指明要操作的文件（不再使用文件名）</li>
</ol>
<p><strong>关闭</strong>：</p>
<ol>
<li>删除打开文件表中的对应表项</li>
<li>回收内存空间</li>
<li><strong>系统打开文件表</strong>的打开计数器cnt-1，若cnt&#x3D;0则删除表项</li>
</ol>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><ul>
<li><p>硬链接：</p>
<p>  只有cnt&#x3D;0时外存中的文件才会被删除</p>
</li>
</ul>
<p><img src="/img/os_img/%E7%A1%AC%E9%93%BE%E6%8E%A5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>软连接：</p>
<p>  类似于windows的快捷方式，共享文件被删除后就无法访问</p>
</li>
</ul>
<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><ul>
<li>口令保护：为文件设置一个口令，用户提供口令以访问文件。口令存在系统中，不安全</li>
<li>加密保护：用一个密码对文件加密，用户提供密码对文件反向解密。加解密需要耗费时间</li>
<li>访问控制：用访问控制表(ACL)，记录用户&#x2F;组的访问权限。灵活，可以实现复杂的文件保护功能</li>
</ul>
<h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3><p><img src="/img/os_img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>用户需要通过操作系统提供的接口发出上述请求——用户接口</li>
<li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录 项——文件目录系统</li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限—— 存取控制模块（存取控制验证层）</li>
<li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——逻辑文 件系统与文件信息缓冲区</li>
<li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</li>
<li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li>
<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</li>
</ul>
<h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><ul>
<li><p>在磁盘中的结构</p>
<p>  <img src="/img/os_img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80%E7%A3%81%E7%9B%98.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>在内存中的结构</p>
<ul>
<li>目录结构缓存</li>
<li>系统打开文件表</li>
<li>进程打开文件表</li>
</ul>
</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>屏蔽不同文件系统的差异和操作细节，向上为用户提供了文件操作的统一调用接口</p>
<p><img src="/img/os_img/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" srcset="/img/loading.gif" lazyload></p>
<p>虚拟节点用来统一在<strong>主存</strong>中的文件数据结构</p>
<p><img src="/img/os_img/vnode.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>文件系统挂载</strong></p>
<p>在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包含文件系统类型、容量大小等。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/" class="category-chain-item">考研</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%80%83%E7%A0%94/">#考研</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统</div>
      <div>http://xwww12.github.io/2024/04/11/考研/操作系统基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>xw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月11日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/24/%E8%80%83%E7%A0%94/%E6%97%A5%E8%AF%AD/" title="日语">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">日语</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/01/%E8%80%83%E7%A0%94/%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80/" title="高数基础">
                        <span class="hidden-mobile">高数基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 10px"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/snow2.js"></script>
<script src="/js/pageTitle.js"></script>
<script src="/js/sakura.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
